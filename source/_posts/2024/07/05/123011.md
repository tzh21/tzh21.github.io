---
title: Next.js 认证 / 授权 / 登录
date: 2024-07-05 12:30:12
tags:
  - Front End
---

## 概念

认证（Authentication）：服务器识别用户的身份。

授权（Authorization）：在认证之后，服务器根据用户的身份，决定该用户可以访问哪些资源。


## 实现认证

```ts
import NextAuth from 'next-auth';
import Credentials from 'next-auth/providers/credentials';
import { sql } from '@vercel/postgres';
import { z } from 'zod';
import type { User } from '@/app/lib/definitions';

// 推荐使用 bcryptjs 包而不是 bcrypt 包。使用 bcrypt 包时可能会遇到错误，参考 https://github.com/kelektiv/node.bcrypt.js/issues/1017
const bcrypt = require('bcryptjs')

// 从数据库中获取指定 email 的用户，用于后续的比对
async function getUser(email: string): Promise<User | undefined> {
  try {
    const user = await sql<User>`SELECT * FROM users WHERE email=${email}`;
    return user.rows[0];
  } catch (error) {
    console.error('Failed to fetch user:', error);
    throw new Error('Failed to fetch user.');
  }
}

// next-auth 提供了一系列处理认证的成熟套件，只需要提供一些必要的参数即可。尽可能使用这些套件而不是手搓。
export const { auth, signIn, signOut } = NextAuth({
  pages: {
    signIn: '/login',
  },
  // 认证的逻辑。可以添加多个认证提供方，这里使用最原始的账号密码认证 Credentials。
  providers: [
    Credentials({
      // credentials 包含账号和密码，将其与数据库中的进行对比。
      // 如果对比成功，返回数据库中的账户，如果对比失败，返回 null。
      async authorize(credentials) {
        const parsedCredentials = z
          .object({ email: z.string().email(), password: z.string().min(6) })
          .safeParse(credentials);

        if (parsedCredentials.success) {
          const { email, password } = parsedCredentials.data;

          const user = await getUser(email);
          if (!user) return null;

          const passwordsMatch = await bcrypt.compare(password, user.password);
          if (passwordsMatch) return user;
        }

        console.log('Invalid credentials');
        return null;
      },
    }),
  ]
});
```

前端登录表单 

```ts
import { signIn } from '@/auth';
import { useActionState } from 'react';

// 提交登录表单
export async function authenticate(
  prevState: string | undefined,
  formData: FormData,
) {
  try {
    // 这里用到了 next-auth 的登录组件
    await signIn('credentials', formData);
  } catch (error) {
    if (error instanceof AuthError) {
      switch (error.type) {
        case 'CredentialsSignin':
          return 'Invalid credentials.';
        default:
          return 'Something went wrong.';
      }
    }
    throw error;
  }
}

export default function LoginForm() {
  const [errorMessage, formAction, isPending] = useActionState(
    authenticate,
    undefined,
  );
  ...
  return (
    <form action={formAction}>
      <input>...</input>
      <input>...</input>
    </form>
  )
}
```

## 实现授权

授权是通过 Next.js 的中间件机制完成的。

根目录 `middleware.ts`，文件名不能自定义。
```ts
import { auth } from "@/auth"

export default auth((req) => {
  if (!req.auth && req.nextUrl.pathname !== "/login") {
    const newUrl = new URL("/login", req.nextUrl.origin)
    return Response.redirect(newUrl)
  }
  else if (req.auth && !req.nextUrl.pathname.startsWith("/dashboard")) {
    const newUrl = new URL("/dashboard", req.nextUrl.origin)
    return Response.redirect(newUrl)
  }
})

// 必需；让前端页面可以正常地访问图片等资源，无需认证。
export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico).*)"],
}
```
